<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Crossword (Open Source Clone)</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --ink:#e5e7eb; /* gray-200 */
      --muted:#94a3b8; /* slate-400 */
      --accent:#22d3ee; /* cyan-400 */
      --accent-2:#a78bfa; /* violet-400 */
      --good:#34d399; /* emerald-400 */
      --bad:#f87171; /* red-400 */
      --warn:#fbbf24; /* amber-400 */
      --shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(160deg, #0b1026, #0f172a 30%, #0b1026 100%);
      color:var(--ink);
      display:grid; place-items:center; padding:20px;
    }
    .app{width:min(1100px, 100%); display:grid; gap:16px; grid-template-columns: 1.1fr .9fr; align-items:start}
    @media (max-width: 900px){ .app{grid-template-columns:1fr} }

    header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    .brand{display:flex; align-items:center; gap:12px}
    .logo{width:42px; height:42px; border-radius:12px; background: linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow:var(--shadow)}
    h1{font-size: clamp(20px, 2.6vw, 32px); margin:0}

    .panel{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); padding:14px; border-radius:16px; box-shadow:var(--shadow)}

    .grid-wrap{display:grid; gap:12px}
    .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button, .btn{
      background:#111827; color:var(--ink); border:1px solid rgba(255,255,255,.12); border-radius:12px;
      padding:10px 12px; cursor:pointer; font-weight:600; letter-spacing:.2px; box-shadow:var(--shadow);
    }
    button:hover{border-color:var(--accent);}
    button[disabled]{opacity:.5; cursor:not-allowed}

    .status{display:flex; align-items:center; gap:10px; color:var(--muted)}
    .badge{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px}

    .grid{ --n:5; --cell:56px; position:relative; width: calc(var(--n) * var(--cell)); height: calc(var(--n) * var(--cell));
      display:grid; grid-template-columns: repeat(var(--n), var(--cell)); grid-template-rows: repeat(var(--n), var(--cell));
      background:#000; border-radius:12px; overflow:hidden; border:2px solid rgba(255,255,255,.1); box-shadow:var(--shadow);
      touch-action: manipulation;
    }
    @media (max-width: 500px){ .grid{ --cell:48px } }
    @media (max-width: 380px){ .grid{ --cell:42px } }

    .cell{ position:relative; display:grid; place-items:center; background:#fff; color:#111; font-weight:700;
      user-select:none; -webkit-user-select:none; font-size: 24px; line-height:1; text-transform:uppercase;
    }
    .cell input{ position:absolute; inset:0; opacity:0; }
    .cell.black{ background:#111; }
    .num{ position:absolute; top:3px; left:4px; font-size:11px; color:#111; font-weight:700; opacity:.9 }
    .cell.black .num{ display:none }

    .cell.sel{ outline: 3px solid var(--accent) }
    .cell.word{ background: #eaf9fc }
    .cell.err{ background: #ffecec }
    .cell.revealed{ color: #10b981 }

    .clues{ display:grid; gap:14px }
    .clue-list{ display:grid; gap:8px }
    .clue-list h3{ margin:.2rem 0; color:var(--muted) }
    .clue{ display:flex; gap:8px; padding:8px; border-radius:10px; cursor:pointer; align-items:flex-start }
    .clue:hover{ background: rgba(255,255,255,.04) }
    .clue.active{ background: rgba(34, 211, 238, .12); border:1px solid rgba(34,211,238,.35) }
    .clue .num{ position:static; color:var(--ink) }
    .clue .text{ color:var(--ink) }

    .meta{ display:flex; gap:10px; flex-wrap:wrap }
    .timer{ font-variant-numeric: tabular-nums; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12) }

    .notice{ font-size:12px; color:var(--muted) }

    .hidden{ display:none }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <header>
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 id="title">Mini Crossword</h1>
            <div id="subtitle" class="notice">An original, NYT-inspired implementation. No proprietary content.</div>
          </div>
        </div>
        <div class="meta">
          <span class="timer" id="timer">00:00</span>
          <button id="btnNew">New</button>
          <button id="btnCheck">Check</button>
          <button id="btnReveal">Reveal</button>
          <button id="btnClear">Clear</button>
        </div>
      </header>

      <div class="grid-wrap" style="margin-top:12px">
        <div class="toolbar">
          <span class="status">
            <span class="badge" id="dirBadge">Across</span>
            <span class="badge" id="progress">0 / 0</span>
          </span>
          <label class="btn" for="puzFile">Load puzzleâ€¦ <input id="puzFile" class="hidden" type="file" accept="application/json"></label>
          <a id="dlState" class="btn" download>Export save</a>
        </div>
        <div class="grid" id="grid" role="grid" aria-label="Crossword grid"></div>
      </div>
    </div>

    <aside class="panel clues" aria-label="Clues">
      <div class="clue-list">
        <h3>Across</h3>
        <div id="across"></div>
      </div>
      <div class="clue-list">
        <h3>Down</h3>
        <div id="down"></div>
      </div>
      <div class="notice" id="byline"></div>
    </aside>
  </div>

  <script>
  // --- Puzzle schema ---------------------------------------------------------
  // A puzzle JSON looks like:
  // {
  //   "id": "demo-001",
  //   "title": "Sample Mini",
  //   "author": "You",
  //   "date": "2025-08-27",
  //   "rows": 5,
  //   "cols": 5,
  //   "grid": [
  //     "HELLO",
  //     "E#L#O",
  //     "LLAMA",
  //     "O#R#E",
  //     "WORLD"
  //   ],
  //   "clues": {
  //     "across": { "1": "Greeting", "3": "Not yes", ... },
  //     "down":   { "1": "Opposite of off", ... }
  //   }
  // }
  // Use '#' for black squares. Letters are the solution.

  const SAMPLE = {
    id: 'demo-001',
    title: 'Tiny Demo',
    author: 'Your Name',
    date: '2025-08-27',
    rows: 5,
    cols: 5,
    grid: [
      'P#PUP',
      'EALOE',
      'A#N#A',
      'RIVER',
      'S#E#S',
    ],
    clues: {
      across: {
        '1':'Carbonated drink, informally',
        '3':'Young dog',
        '5':'Desert plant',
        '6':'Vowel after L',
        '7':'Flowing body of water',
      },
      down: {
        '1':'Brownish-orange color',
        '2':'Ocean (poetic)',
        '4':'Naval rank abbr.',
        '5':'Opposite of W',
      }
    }
  };

  // --- State ----------------------------------------------------------------
  let PUZ = null; // loaded puzzle
  let state = { cells: [], cursor: 0, dir: 'across', startedAt: null, elapsed: 0, finishedAt: null };

  const els = {
    grid: document.getElementById('grid'),
    across: document.getElementById('across'),
    down: document.getElementById('down'),
    dirBadge: document.getElementById('dirBadge'),
    progress: document.getElementById('progress'),
    title: document.getElementById('title'),
    subtitle: document.getElementById('subtitle'),
    byline: document.getElementById('byline'),
    timer: document.getElementById('timer'),
    btnNew: document.getElementById('btnNew'),
    btnCheck: document.getElementById('btnCheck'),
    btnReveal: document.getElementById('btnReveal'),
    btnClear: document.getElementById('btnClear'),
    puzFile: document.getElementById('puzFile'),
    dlState: document.getElementById('dlState'),
  };

  // --- Utils ----------------------------------------------------------------
  const idx = (r,c)=> r*PUZ.cols + c;
  const inBounds = (r,c)=> r>=0 && c>=0 && r<PUZ.rows && c<PUZ.cols;
  const isBlack = (r,c)=> PUZ.grid[r][c] === '#';
  const letterAt = (r,c)=> PUZ.grid[r][c];
  const cellEl = i => document.querySelector(`.cell[data-i="${i}"]`);
  const saveKey = ()=> `mini:${PUZ.id}`;

  const formatTime = s => {
    const m = Math.floor(s/60); const ss = Math.floor(s%60);
    return String(m).padStart(2,'0')+':'+String(ss).padStart(2,'0');
  };

  function autoNumbers(){
    const nums = Array(PUZ.rows * PUZ.cols).fill(null);
    let n = 0;
    for(let r=0;r<PUZ.rows;r++){
      for(let c=0;c<PUZ.cols;c++){
        if(isBlack(r,c)) continue;
        const startAcross = (c===0 || isBlack(r,c-1));
        const startDown   = (r===0 || isBlack(r-1,c));
        if(startAcross || startDown){ n++; nums[idx(r,c)] = n; }
      }
    }
    return nums;
  }

  function buildWordMap(){
    // Map index -> word indices for across/down
    const words = { across: {}, down: {} };
    const nums = autoNumbers();

    // Across
    for(let r=0;r<PUZ.rows;r++){
      let c=0; while(c<PUZ.cols){
        if(isBlack(r,c)){ c++; continue; }
        const start = c;
        const number = nums[idx(r,c)];
        while(c<PUZ.cols && !isBlack(r,c)) c++;
        const cells = [];
        for(let cc=start; cc<c; cc++) cells.push(idx(r,cc));
        words.across[number] = cells;
      }
    }
    // Down
    for(let c=0;c<PUZ.cols;c++){
      let r=0; while(r<PUZ.rows){
        if(isBlack(r,c)){ r++; continue; }
        const start = r;
        const number = nums[idx(r,c)];
        while(r<PUZ.rows && !isBlack(r,c)) r++;
        const cells = [];
        for(let rr=start; rr<r; rr++) cells.push(idx(rr,c));
        words.down[number] = cells;
      }
    }
    return { nums, words };
  }

  // --- Rendering -------------------------------------------------------------
  function renderGrid(){
    els.grid.style.setProperty('--n', PUZ.cols);
    els.grid.innerHTML = '';
    state.cells = Array(PUZ.rows*PUZ.cols).fill('');
    const { nums } = buildWordMap();

    for(let r=0;r<PUZ.rows;r++){
      for(let c=0;c<PUZ.cols;c++){
        const i = idx(r,c);
        const div = document.createElement('div');
        div.className = 'cell'+(isBlack(r,c)?' black':'');
        div.dataset.i = i;
        div.setAttribute('role','gridcell');
        if(!isBlack(r,c)){
          const num = nums[i];
          if(num) { const n = document.createElement('div'); n.className='num'; n.textContent=num; div.appendChild(n); }
          const input = document.createElement('input');
          input.setAttribute('inputmode','latin');
          input.setAttribute('maxlength','1');
          input.addEventListener('focus', ()=> selectCell(i));
          input.addEventListener('beforeinput', (e)=> {
            if(e.data && /[A-Za-z]/.test(e.data)) e.data = e.data.toUpperCase();
          });
          input.addEventListener('input', (e)=> typeChar(i, e.target.value.toUpperCase()));
          div.appendChild(input);
          div.addEventListener('click', ()=> handleTap(i));
        }
        els.grid.appendChild(div);
      }
    }
  }

  function renderClues(){
    const { nums, words } = buildWordMap();
    // Build clue listing based on numbering present
    function build(listEl, dir){
      listEl.innerHTML = '';
      const entries = Object.keys(words[dir]).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
      for(const n of entries){
        const item = document.createElement('div'); item.className='clue'; item.dataset.dir = dir; item.dataset.num = n;
        const num = document.createElement('div'); num.className='num'; num.textContent=n; item.appendChild(num);
        const text = document.createElement('div'); text.className='text';
        const clue = (PUZ.clues?.[dir]?.[String(n)]) || `[${dir}]`;
        text.textContent = clue; item.appendChild(text);
        item.addEventListener('click', ()=> selectWordByNumber(dir, n));
        listEl.appendChild(item);
      }
    }
    build(els.across, 'across');
    build(els.down, 'down');
  }

  function updateUI(){
    const total = PUZ.rows*PUZ.cols - PUZ.grid.flatMap(r=>r.split('')).filter(ch=>ch==='#').length;
    const filled = state.cells.filter((ch,i)=> ch && PUZ.grid[Math.floor(i/PUZ.cols)][i%PUZ.cols] !== '#').length;
    els.progress.textContent = `${filled} / ${total}`;

    // highlight selection
    document.querySelectorAll('.cell').forEach(el=> el.classList.remove('sel','word','err'));
    const i = state.cursor;
    const r = Math.floor(i/PUZ.cols), c=i%PUZ.cols;
    const me = cellEl(i);
    if(me){ me.classList.add('sel'); me.querySelector('input')?.focus({preventScroll:true}); }

    const { words } = buildWordMap();
    const group = (words[state.dir] || {});
    const numHere = Object.entries(group).find(([,cells])=> cells.includes(i));
    if(numHere){
      const cells = numHere[1];
      cells.forEach(ci=> cellEl(ci)?.classList.add('word'));
      document.querySelectorAll('.clue').forEach(c=> c.classList.remove('active'));
      const clueEl = document.querySelector(`.clue[data-dir="${state.dir}"][data-num="${numHere[0]}"]`);
      clueEl?.classList.add('active');
    }

    // write letters
    for(let k=0;k<state.cells.length;k++){
      const el = cellEl(k);
      if(!el || el.classList.contains('black')) continue;
      el.dataset.v = state.cells[k]||'';
      el.textContent = state.cells[k]||'';
      const n = el.querySelector('.num'); if(n){ el.prepend(n); }
      const inp = el.querySelector('input'); if(inp){ inp.value = state.cells[k]||''; }
    }

    // timer
    const now = Date.now();
    const elapsed = state.finishedAt ? state.finishedAt - state.startedAt : now - (state.startedAt||now);
    els.timer.textContent = formatTime(Math.max(0, Math.floor((state.elapsed + (state.startedAt?elapsed/1000:0)))));

    // save
    persist();
  }

  // --- Interaction -----------------------------------------------------------
  function selectCell(i){
    state.cursor = i; updateUI();
  }

  function handleTap(i){
    if(state.cursor===i){ toggleDir(); } else { selectCell(i); }
  }

  function toggleDir(){
    state.dir = state.dir==='across'?'down':'across';
    els.dirBadge.textContent = state.dir.charAt(0).toUpperCase()+state.dir.slice(1);
    updateUI();
  }

  function move(delta){
    const step = state.dir==='across' ? 1 : PUZ.cols;
    let i = state.cursor + delta*step;
    while(i>=0 && i<PUZ.rows*PUZ.cols){
      const r=Math.floor(i/PUZ.cols), c=i%PUZ.cols; if(!isBlack(r,c)) break; i += delta*step;
    }
    if(i>=0 && i<PUZ.rows*PUZ.cols) selectCell(i);
  }

  function typeChar(i, ch){
    if(!state.startedAt){ state.startedAt = Date.now(); }
    if(!ch){ state.cells[i]=''; updateUI(); return; }
    if(!/[A-Z]/.test(ch)) return;
    state.cells[i] = ch;
    // move forward
    move(+1);
  }

  function backspace(){
    const i = state.cursor; if(state.cells[i]){ state.cells[i]=''; updateUI(); return; }
    // move back then clear
    const prev = state.dir==='across'? i-1 : i-PUZ.cols; if(prev>=0) { selectCell(prev); state.cells[prev]=''; }
    updateUI();
  }

  function checkCurrent(){
    const { words } = buildWordMap();
    const group = words[state.dir];
    const entry = Object.entries(group).find(([,cells])=> cells.includes(state.cursor));
    const cells = entry? entry[1] : [state.cursor];
    let allGood=true;
    for(const i of cells){
      const r=Math.floor(i/PUZ.cols), c=i%PUZ.cols;
      const correct = letterAt(r,c);
      if((state.cells[i]||'') !== correct){ allGood=false; cellEl(i)?.classList.add('err'); }
    }
    if(allGood){
      // confetti-lite
      flash(`Nice! '${entry?entry[0]:''}' correct.`);
      // if puzzle complete -> stop timer
      if(isComplete()){ state.finishedAt = Date.now(); updateUI(); flash('Puzzle complete!'); }
    }
  }

  function revealCurrent(){
    const { words } = buildWordMap();
    const group = words[state.dir];
    const entry = Object.entries(group).find(([,cells])=> cells.includes(state.cursor));
    const cells = entry? entry[1] : [state.cursor];
    for(const i of cells){
      const r=Math.floor(i/PUZ.cols), c=i%PUZ.cols; state.cells[i] = letterAt(r,c);
      cellEl(i)?.classList.add('revealed');
    }
    updateUI();
  }

  function isComplete(){
    for(let r=0;r<PUZ.rows;r++){
      for(let c=0;c<PUZ.cols;c++){
        if(isBlack(r,c)) continue;
        const i=idx(r,c);
        if(!state.cells[i]) return false;
        if(state.cells[i] !== letterAt(r,c)) return false;
      }
    }
    return true;
  }

  function clearAll(){ state.cells = state.cells.map(()=> ''); state.startedAt=null; state.elapsed=0; state.finishedAt=null; updateUI(); }

  // --- Persistence -----------------------------------------------------------
  function persist(){
    const data = { cells: state.cells, dir: state.dir, elapsed: state.elapsed + (state.startedAt? (Date.now()-state.startedAt)/1000 : 0), finishedAt: state.finishedAt };
    try{ localStorage.setItem(saveKey(), JSON.stringify(data)); }catch(e){}
    // update download link
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    els.dlState.href = URL.createObjectURL(blob);
    els.dlState.download = `${PUZ.id}-save.json`;
  }

  function restore(){
    try{
      const raw = localStorage.getItem(saveKey()); if(!raw) return;
      const data = JSON.parse(raw);
      state.cells = data.cells || state.cells;
      state.dir = data.dir || state.dir;
      state.elapsed = data.elapsed || 0;
      state.finishedAt = data.finishedAt || null;
      els.dirBadge.textContent = state.dir.charAt(0).toUpperCase()+state.dir.slice(1);
    }catch(e){}
  }

  // --- Feedback --------------------------------------------------------------
  function flash(msg){
    const div = document.createElement('div');
    div.textContent = msg; div.style.position='fixed'; div.style.bottom='20px'; div.style.left='50%'; div.style.transform='translateX(-50%)';
    div.style.padding='10px 14px'; div.style.background='rgba(17,24,39,.9)'; div.style.border='1px solid rgba(255,255,255,.15)'; div.style.borderRadius='12px'; div.style.color='white'; div.style.boxShadow=var(--shadow);
    document.body.appendChild(div); setTimeout(()=> div.remove(), 1500);
  }

  // --- Loading ---------------------------------------------------------------
  async function loadPuzzle(puz){
    PUZ = puz;
    els.title.textContent = PUZ.title || 'Mini Crossword';
    els.subtitle.textContent = PUZ.date ? `Puzzle date: ${PUZ.date}` : 'Custom puzzle';
    els.byline.textContent = PUZ.author ? `By ${PUZ.author}` : '';
    renderGrid();
    renderClues();
    restore();
    selectFirstCell();
    updateUI();
  }

  function selectFirstCell(){
    for(let i=0;i<PUZ.rows*PUZ.cols;i++){
      const r=Math.floor(i/PUZ.cols), c=i%PUZ.cols; if(!isBlack(r,c)){ state.cursor=i; break; }
    }
  }

  async function fetchPuzzleFromURL(url){
    const res = await fetch(url);
    if(!res.ok) throw new Error('Failed to fetch puzzle');
    return await res.json();
  }

  // Try to load ?puzzle=URL or ?date=YYYY-MM-DD -> puzzles/YYYY-MM-DD.json
  async function boot(){
    const params = new URLSearchParams(location.search);
    try{
      if(params.get('puzzle')){
        const data = await fetchPuzzleFromURL(params.get('puzzle'));
        await loadPuzzle(data); return;
      }
      if(params.get('date')){
        const date = params.get('date');
        const data = await fetchPuzzleFromURL(`puzzles/${date}.json`);
        await loadPuzzle(data); return;
      }
    }catch(e){ console.error(e); flash('Failed to load provided puzzle. Loading sample.'); }
    await loadPuzzle(SAMPLE);
  }

  // --- Event wiring ----------------------------------------------------------
  document.addEventListener('keydown', (e)=>{
    const active = document.activeElement;
    if(active && active.tagName==='INPUT'){
      if(e.key==='Backspace'){ e.preventDefault(); backspace(); }
      if(e.key==='Enter'){ e.preventDefault(); toggleDir(); }
      if(e.key==='ArrowLeft'){ e.preventDefault(); state.dir='across'; move(-1); }
      if(e.key==='ArrowRight'){ e.preventDefault(); state.dir='across'; move(+1); }
      if(e.key==='ArrowUp'){ e.preventDefault(); state.dir='down'; move(-1); }
      if(e.key==='ArrowDown'){ e.preventDefault(); state.dir='down'; move(+1); }
    }
  });

  els.btnNew.addEventListener('click', ()=> { clearAll(); flash('Cleared. Load a new puzzle JSON to play a fresh game.'); });
  els.btnCheck.addEventListener('click', checkCurrent);
  els.btnReveal.addEventListener('click', revealCurrent);
  els.btnClear.addEventListener('click', clearAll);
  els.puzFile.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    const text = await file.text();
    try{ const data = JSON.parse(text); await loadPuzzle(data); }catch(err){ alert('Invalid puzzle JSON'); }
  });

  // Keep timer fresh every 500ms
  setInterval(()=> updateUI(), 500);

  boot();
  </script>
</body>
</html>
